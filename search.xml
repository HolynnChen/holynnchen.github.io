<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>最长递增子序列</title>
    <url>/2020/03/02/algorithm/</url>
    <content><![CDATA[<blockquote>
<p>前言：看了别人一道算法题思考了几分钟才想明白解法，老了老了，好久没碰算法了，重新记录下</p>
</blockquote>
<a id="more"></a>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>&emsp;&emsp;在一串非排序数组中，寻找一最长递增子序列，并返回其长度。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="O-n2"><a href="#O-n2" class="headerlink" title="O(n2)"></a>O(n<sup>2</sup>)</h2><p>&emsp;&emsp;使用动态规划解法去做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums&#x3D;[1,2,3,5,4,6] #输入</span><br><span class="line">length&#x3D;[1]*len(nums) #初始化某位置的最长子序列</span><br><span class="line"></span><br><span class="line">for i in range(1,len(nums)):</span><br><span class="line">    length[i]&#x3D;max([1]+[length[j]+1 for j in range(i) if nums[j]&lt;nums[i]])</span><br><span class="line">result&#x3D;max(length)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当为第一个时，必为0。为避免max([])的情况出现，增加了一个[1]到原数组。+1代表加上位置i上的数字后子序列长度增加1。</p>
<h2 id="0-nlog-n"><a href="#0-nlog-n" class="headerlink" title="0(nlog(n))"></a>0(nlog(n))</h2><p>&emsp;&emsp;寻找贪心情况下递减子序列个数</p>
<p>&emsp;&emsp;详细解答可以看<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md" target="_blank" rel="noopener">这个</a>，这里主要记录一下实现。有一个重要的点就是，tops必然是递增的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums&#x3D;[1,2,3,5,4,6] #输入</span><br><span class="line">tops&#x3D;[nums[0]]</span><br><span class="line">tops&#x3D;[nums[0]]</span><br><span class="line"></span><br><span class="line">def search_index(num,left,right):#查找恰比num大的tops中的第一个数的索引</span><br><span class="line">    if left&#x3D;&#x3D;right:</span><br><span class="line">        if tops[right]&lt;num:</span><br><span class="line">            return -1</span><br><span class="line">        return right</span><br><span class="line">    mid&#x3D;(left+right)&#x2F;&#x2F;2</span><br><span class="line">    if tops[mid]&gt;num:</span><br><span class="line">        return search_index(num,left,mid)</span><br><span class="line">    else:</span><br><span class="line">        return search_index(num,mid+1,right)</span><br><span class="line"></span><br><span class="line">for i in nums[1:]:</span><br><span class="line">    temp&#x3D;search_index(i,0,len(tops)-1)</span><br><span class="line">    if temp&#x3D;&#x3D;-1:</span><br><span class="line">        tops.append(i)</span><br><span class="line">    else:</span><br><span class="line">        tops[temp]&#x3D;i</span><br><span class="line">result&#x3D;len(tops)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>有关session与token在技术选型上的一些思考</title>
    <url>/2020/03/01/about-session-and-token/</url>
    <content><![CDATA[<blockquote>
<p>前言：在做毕设中对有关session与token在技术选型上进行了一些深入的思考，以此记录，判明两者应该适合什么场景，各有哪些缺陷。</p>
</blockquote>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>&emsp;&emsp;在我的毕设中，涉及到了路由鉴权，当然这也是目前大多数系统中必然拥有的功能，为什么我把它单独拿出来说一遍呢，因为我在应用过程中经历了以下阶段：</p>
<pre class="mermaid">graph LR
    A("session(redis)")
    B("自定义jwt")
    C("标准jwt")
    A-->B-->C</pre>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>&emsp;&emsp;一开始是并没有考虑到很严格的性能控制，因此是采用了session设计，该特点在于比较安全，服务端可以控制客户的登录状态，同时确保用户状态的一致性。<br>&emsp;&emsp;后来是考虑到为了方便服务的拓展，因此把本来的基于redis的集中式session改成了无状态的jwt，为什么是自定义呢，因为我太蠢了，一开始想偷懒直接写了个自定义的jst和不完整的oauth2.0，后来才发现有安全风险就改掉，改为标准jwt了。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>&emsp;&emsp;当然，会有人提出疑问，有什么区别，不安全在哪，如何解决？这些就是我接下来要解决的问题。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">session</th>
<th align="center">jwt</th>
</tr>
</thead>
<tbody><tr>
<td align="center">识别方式</td>
<td align="center">session_id</td>
<td align="center">access_token</td>
</tr>
<tr>
<td align="center">储存位置</td>
<td align="center">redis+token<sup>1</sup></td>
<td align="center">token<sup>1</sup></td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">较高</td>
<td align="center">较低</td>
</tr>
<tr>
<td align="center">实时性</td>
<td align="center">较高</td>
<td align="center">较低</td>
</tr>
<tr>
<td align="center">缺陷</td>
<td align="center">频繁查询redis<br>在分布式系统中有较大网络压力</td>
<td align="center">用户信息无法实时更新<br>状态无法注销</td>
</tr>
<tr>
<td align="center">解决方法</td>
<td align="center">增加配置<br>部署redis集群</td>
<td align="center">对数据库重要变更时<br>以数据库内信息为准验证<sup>2</sup></td>
</tr>
</tbody></table>
<blockquote>
<p>注1：token可储存在web用户的cookie里<br><br>注2：如涉及数据删除、系统设置变更等</p>
</blockquote>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>&emsp;&emsp;session可以说是最传统的会话管理方案了，自然也十分稳定，但是矛盾只突出在于比较适合单机或小集群，一旦redis挂了会话就会丢失。</p>
<h2 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h2><p>&emsp;&emsp;全称JSON Web Token，是无状态的跨域认证解决方案，详细介绍可以看看<a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">阮一峰的文章</a>，这里就不做详细介绍</p>
<h1 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h1><h2 id="session-1"><a href="#session-1" class="headerlink" title="session"></a>session</h2><p>&emsp;&emsp;我个人认为小集群或单机，或者是起步阶段完全可以用session管理，十分成熟，往往有现成的中间件使用。</p>
<h2 id="jwt-1"><a href="#jwt-1" class="headerlink" title="jwt"></a>jwt</h2><p>&emsp;&emsp;有多个服务或域名，希望能跨服务共享用户信息的状况，或者是服务体量已经达到一定规模，希望优化性能等情况。</p>
<h2 id="session-jwt"><a href="#session-jwt" class="headerlink" title="session+jwt"></a>session+jwt</h2><p>&emsp;&emsp;看起来是多次一举，但或许未来可能有业务用得上。在某个要求实时性、一致性高的闭环业务/功能中可以采用session来储存状态，小范围应用，确保规模不是很大，其他范围使用jwt来保存用户基本信息，如id/name/role等。设定较短的access_token与较长的refresh_token就能在较宽松范围内保证数据良好。在前端可以通过操作了某些业务后立刻调用refresh_token来刷新。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;没有银弹方案，初始阶段完全可以不用考虑太多，使用session即可，一般来说每秒几百到几千并发不是什么大问题。到后期业务拓展的时候再更换为jwt也可以，但是要求前期设计的时候就要有比较良好的模块化设计，便于重构</p>
]]></content>
      <tags>
        <tag>技术选型</tag>
      </tags>
  </entry>
</search>
